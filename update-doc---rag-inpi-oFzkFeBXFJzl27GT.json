{"updatedAt":"2025-06-24T15:05:03.916Z","createdAt":"2025-06-23T12:23:52.966Z","id":"oFzkFeBXFJzl27GT","name":"Update Doc - RAG INPI","active":true,"isArchived":false,"nodes":[{"parameters":{"html":"<!DOCTYPE html>\n<html lang=\"pt-BR\">\n<head>\n   <meta charset=\"UTF-8\">\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   <title>Document Upload</title>\n   <script src=\"https://cdn.tailwindcss.com\"></script>\n</head>\n<body>\n   <div class=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n       <div class=\"bg-white rounded-lg shadow-lg border border-gray-200 p-8 w-full max-w-md\">\n           <div class=\"text-center mb-6\">\n               <div class=\"w-12 h-12 bg-green-500 rounded-md flex items-center justify-center mx-auto mb-4\">\n                   <svg class=\"w-6 h-6 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                       <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n                   </svg>\n               </div>\n               <h1 class=\"text-xl font-semibold text-gray-900\">Upload Document AGENT CREATOR CONTENT</h1>\n               <p class=\"text-sm text-gray-500\">PDF, DOC, DOCX, TXT, MD, XML</p>\n           </div>\n\n           <form id=\"uploadForm\" class=\"space-y-4\">\n               <div>\n                   <input \n                       type=\"file\" \n                       id=\"fileInput\" \n                       accept=\".pdf,.doc,.docx,.txt,.md, .xml\"\n                       class=\"block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100\"\n                       required\n                   />\n               </div>\n               \n               <button \n                   type=\"submit\" \n                   id=\"uploadBtn\"\n                   class=\"w-full bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-md transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed\"\n               >\n                   Upload Document\n               </button>\n           </form>\n\n           <!-- Status message -->\n           <div id=\"statusMessage\" class=\"mt-4 hidden\"></div>\n       </div>\n   </div>\n\n   <script>\n       const form = document.getElementById('uploadForm');\n       const fileInput = document.getElementById('fileInput');\n       const uploadBtn = document.getElementById('uploadBtn');\n       const statusMessage = document.getElementById('statusMessage');\n       const webhookUrl = 'https://primary-production-70c40.up.railway.app/webhook-test/7bcfb3a8-c514-42bd-9f80-cb1ede1a3d64';\n\n       form.addEventListener('submit', async (e) => {\n           e.preventDefault();\n           \n           const file = fileInput.files[0];\n           if (!file) {\n               showMessage('Please select a file', 'error');\n               return;\n           }\n\n           // Validate file\n           if (!validateFile(file)) {\n               return;\n           }\n\n           // Disable button and show loading\n           uploadBtn.disabled = true;\n           uploadBtn.textContent = 'Uploading...';\n           showMessage('Uploading document...', 'loading');\n\n           try {\n               const formData = new FormData();\n               formData.append('file', file);\n\n               const response = await fetch(webhookUrl, {\n                   method: 'POST',\n                   body: formData\n               });\n\n               if (response.ok) {\n                   showMessage('Document uploaded successfully!', 'success');\n                   form.reset();\n               } else {\n                   throw new Error(`Upload failed: ${response.status}`);\n               }\n           } catch (error) {\n               console.error('Upload error:', error);\n               showMessage('Upload failed. Please try again.', 'error');\n           } finally {\n               uploadBtn.disabled = false;\n               uploadBtn.textContent = 'Upload Document';\n           }\n       });\n\n       function validateFile(file) {\n          const allowedTypes = [\n              'application/pdf',\n              'application/msword',\n              'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n              'text/plain',\n              'text/markdown',\n              'application/xml',\n              'text/xml',\n              'application/xhtml+xml'\n          ];\n           \n           const maxSize = 50 * 1024 * 1024; // 10MB\n\n           if (!allowedTypes.includes(file.type)) {\n               showMessage('File type not supported: ' + file.name, 'error');\n               return false;\n           }\n\n           if (file.size > maxSize) {\n               showMessage('File too large: ' + file.name + '. Maximum 10MB.', 'error');\n               return false;\n           }\n\n           return true;\n       }\n\n       function showMessage(message, type) {\n           statusMessage.className = 'mt-4 p-3 rounded-md text-sm';\n           statusMessage.classList.remove('hidden');\n           \n           switch (type) {\n               case 'success':\n                   statusMessage.className += ' bg-green-100 text-green-800 border border-green-200';\n                   break;\n               case 'error':\n                   statusMessage.className += ' bg-red-100 text-red-800 border border-red-200';\n                   break;\n               case 'loading':\n                   statusMessage.className += ' bg-blue-100 text-blue-800 border border-blue-200';\n                   break;\n           }\n           \n           statusMessage.textContent = message;\n       }\n   </script>\n</body>\n</html>"},"type":"n8n-nodes-base.html","typeVersion":1.2,"position":[-40,-100],"id":"83ca966c-e2e6-484e-85a5-148f3cbaf0a7","name":"HTML"},{"parameters":{"respondWith":"text","responseBody":"={{ $json.html }}","options":{}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.3,"position":[180,-100],"id":"269a324a-a706-4817-8389-1bc5c6a79dac","name":"Respond to Webhook"},{"parameters":{"mode":"insert","tableName":{"__rl":true,"value":"revistas_inpi","mode":"list","cachedResultName":"revistas_inpi"},"options":{"queryName":"revistas_inpi"}},"type":"@n8n/n8n-nodes-langchain.vectorStoreSupabase","typeVersion":1.2,"position":[680,100],"id":"c8e1e51c-30f8-4a1e-90c9-7f6299af1295","name":"Supabase Vector Store","credentials":{"supabaseApi":{"id":"ZHIMmNbYxUlvBiKp","name":"teste-vector"}}},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[680,320],"id":"383a39ca-ee6f-4fc9-ba39-e8e6113f9473","name":"Embeddings OpenAI","credentials":{"openAiApi":{"id":"bEHAhmQV1LUjIUXy","name":"OpenAi account"}}},{"parameters":{"dataType":"binary","binaryMode":"specificField","options":{}},"type":"@n8n/n8n-nodes-langchain.documentDefaultDataLoader","typeVersion":1,"position":[800,320],"id":"ff261255-2d5c-4f1f-880c-0375a93856b6","name":"Default Data Loader"},{"parameters":{},"type":"@n8n/n8n-nodes-langchain.textSplitterTokenSplitter","typeVersion":1,"position":[880,500],"id":"416ca37f-3384-447b-aa8a-56afb192d876","name":"Token Splitter"},{"parameters":{"httpMethod":"POST","path":"7bcfb3a8-c514-42bd-9f80-cb1ede1a3d64","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2,"position":[-260,100],"id":"dd59c65b-60dc-4a34-a6d6-2bcaae9a65e1","name":"Webhook1","webhookId":"7bcfb3a8-c514-42bd-9f80-cb1ede1a3d64"},{"parameters":{"path":"c35cc5ef-5a69-4c44-a0b4-4c19473a5c73","responseMode":"responseNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2,"position":[-260,-100],"id":"4653feba-c2d0-444f-81f5-7daf6901714c","name":"Webhook","webhookId":"c35cc5ef-5a69-4c44-a0b4-4c19473a5c73"},{"parameters":{"operation":"binaryToPropery","binaryPropertyName":"file","options":{}},"type":"n8n-nodes-base.extractFromFile","typeVersion":1,"position":[-40,100],"id":"c773de41-1c94-4253-8276-5ae39d40b83b","name":"Extract from File"},{"parameters":{"operation":"toBinary","sourceProperty":"data","options":{}},"type":"n8n-nodes-base.convertToFile","typeVersion":1.1,"position":[180,100],"id":"2181fab0-0777-4459-939d-9c7c2616b5b5","name":"Convert to File"},{"parameters":{"jsCode":"// Código para converter XML para PDF preservando todas as tags\nconst items = $input.all();\nconst outputItems = [];\n\n// Função para criar PDF preservando estrutura XML completa\nfunction createPdfWithXmlStructure(xmlContent) {\n  try {\n    // Função para formatar XML mantendo todas as tags visíveis\n    const formatXmlForPdf = (xmlString) => {\n      // Limpar apenas espaços desnecessários, mantendo toda estrutura\n      let formatted = xmlString\n        .replace(/>\\s+</g, '>\\n<') // Quebra linha entre tags\n        .replace(/^\\s+|\\s+$/gm, '') // Remove espaços das bordas\n        .split('\\n')\n        .map((line, index) => {\n          // Calcular indentação baseada no nível de aninhamento\n          const openTags = (line.match(/</g) || []).length;\n          const closeTags = (line.match(/\\//g) || []).length;\n          const depth = Math.max(0, (line.match(/<(?!\\/)/g) || []).length - closeTags);\n          const indent = '  '.repeat(depth);\n          \n          return line.trim() ? `${String(index + 1).padStart(4, ' ')}: ${indent}${line.trim()}` : '';\n        })\n        .filter(line => line.trim())\n        .join('\\n');\n      \n      return formatted;\n    };\n    \n    const formattedXml = formatXmlForPdf(xmlContent);\n    const pdfBuffer = generatePdfWithXmlContent(formattedXml, xmlContent);\n    \n    return pdfBuffer;\n    \n  } catch (error) {\n    throw new Error(`Erro ao processar XML: ${error.message}`);\n  }\n}\n\n// Gerar PDF com conteúdo XML estruturado\nfunction generatePdfWithXmlContent(formattedText, originalXml) {\n  const lines = formattedText.split('\\n');\n  const maxLinesPerPage = 45; // Menos linhas para dar espaço ao cabeçalho\n  const pages = [];\n  \n  // Dividir em páginas\n  for (let i = 0; i < lines.length; i += maxLinesPerPage) {\n    pages.push(lines.slice(i, i + maxLinesPerPage));\n  }\n  \n  let pdfObjects = [];\n  let objectId = 1;\n  \n  // Objeto 1: Catálogo\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Catalog /Pages 2 0 R >>`\n  });\n  \n  // Objeto 2: Páginas pai\n  const pageRefs = pages.map((_, index) => `${3 + index * 2} 0 R`).join(' ');\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Pages /Kids [${pageRefs}] /Count ${pages.length} >>`\n  });\n  \n  // Criar páginas com conteúdo XML\n  pages.forEach((pageLines, pageIndex) => {\n    const pageId = objectId++;\n    const contentId = objectId++;\n    \n    // Objeto da página\n    pdfObjects.push({\n      id: pageId,\n      content: `<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents ${contentId} 0 R /Resources << /Font << /F1 << /Type /Font /Subtype /Type1 /BaseFont /Courier >> /F2 << /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >> >> >> >>`\n    });\n    \n    // Preparar conteúdo da página com cabeçalho\n    let streamContent = 'BT\\n';\n    \n    // Cabeçalho da página\n    streamContent += '/F2 12 Tf 50 750 Td\\n';\n    streamContent += `(Estrutura XML - Página ${pageIndex + 1} de ${pages.length}) Tj\\n`;\n    streamContent += '0 -20 Td\\n';\n    streamContent += '/F1 8 Tf\\n';\n    streamContent += `(Preservando todas as tags XML para indexação RAG) Tj\\n`;\n    streamContent += '0 -15 Td\\n';\n    streamContent += '(____________________________________________________________) Tj\\n';\n    streamContent += '0 -20 Td\\n';\n    \n    // Conteúdo XML\n    streamContent += '/F1 9 Tf\\n';\n    streamContent += '10 TL\\n'; // Line leading\n    \n    pageLines.forEach(line => {\n      // Escapar caracteres especiais do PDF\n      const escapedLine = line\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\(/g, '\\\\(')\n        .replace(/\\)/g, '\\\\)')\n        .replace(/\\r/g, '')\n        .substring(0, 85); // Limitar tamanho da linha\n      \n      streamContent += `(${escapedLine}) Tj T*\\n`;\n    });\n    \n    streamContent += 'ET';\n    \n    // Objeto de conteúdo\n    pdfObjects.push({\n      id: contentId,\n      content: `<< /Length ${streamContent.length} >>\\nstream\\n${streamContent}\\nendstream`\n    });\n  });\n  \n  // Montar PDF final\n  let pdf = '%PDF-1.4\\n';\n  let xrefTable = [];\n  \n  // Adicionar objetos\n  pdfObjects.forEach(obj => {\n    xrefTable.push(pdf.length);\n    pdf += `${obj.id} 0 obj\\n${obj.content}\\nendobj\\n`;\n  });\n  \n  // Tabela xref\n  const xrefPos = pdf.length;\n  pdf += 'xref\\n';\n  pdf += `0 ${pdfObjects.length + 1}\\n`;\n  pdf += '0000000000 65535 f \\n';\n  \n  xrefTable.forEach(pos => {\n    pdf += pos.toString().padStart(10, '0') + ' 00000 n \\n';\n  });\n  \n  // Trailer\n  pdf += 'trailer\\n';\n  pdf += `<< /Size ${pdfObjects.length + 1} /Root 1 0 R >>\\n`;\n  pdf += 'startxref\\n';\n  pdf += xrefPos + '\\n';\n  pdf += '%%EOF\\n';\n  \n  return Buffer.from(pdf, 'utf8');\n}\n\n// Processar todos os items\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  try {\n    // Extrair conteúdo XML\n    let xmlContent = '';\n    \n    if (item.json && item.json.data) {\n      xmlContent = item.json.data;\n    } else if (item.binary && item.binary.data && item.binary.data.data) {\n      xmlContent = Buffer.from(item.binary.data.data, 'base64').toString('utf8');\n    }\n    \n    if (!xmlContent || xmlContent.trim() === '') {\n      throw new Error('Conteúdo XML não encontrado ou vazio');\n    }\n    \n    console.log(`Processando XML com ${xmlContent.length} caracteres`);\n    \n    // Converter para PDF preservando estrutura\n    const pdfBuffer = createPdfWithXmlStructure(xmlContent);\n    \n    // Preparar dados para RAG (manter XML original + PDF)\n    const outputItem = {\n      json: {\n        // Dados para o RAG\n        originalXml: xmlContent, // XML original completo para indexação\n        fileName: `xml_structured_${Date.now()}.pdf`,\n        mimeType: 'application/pdf',\n        fileSize: pdfBuffer.length,\n        xmlSize: xmlContent.length,\n        processingDate: new Date().toISOString(),\n        tags: extractXmlTags(xmlContent), // Extrair tags para facilitar busca\n        success: true\n      },\n      binary: {\n        data: {\n          data: pdfBuffer.toString('base64'),\n          mimeType: 'application/pdf',\n          fileName: `xml_structured_${Date.now()}.pdf`,\n          fileExtension: 'pdf'\n        }\n      }\n    };\n    \n    outputItems.push(outputItem);\n    \n  } catch (error) {\n    console.error(`Erro no item ${i}:`, error);\n    \n    outputItems.push({\n      json: {\n        error: error.message,\n        itemIndex: i,\n        success: false,\n        processingDate: new Date().toISOString()\n      }\n    });\n  }\n}\n\n// Função auxiliar para extrair tags XML para indexação\nfunction extractXmlTags(xmlContent) {\n  try {\n    const tagMatches = xmlContent.match(/<[^>]+>/g) || [];\n    const uniqueTags = [...new Set(tagMatches.map(tag => {\n      return tag.replace(/[<>\\/]/g, '').split(' ')[0];\n    }))];\n    return uniqueTags.filter(tag => tag.length > 0);\n  } catch (error) {\n    return [];\n  }\n}\n\nreturn outputItems;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[420,100],"id":"a252e8ff-c66c-4c95-9d41-171d858f08af","name":"Code"},{"parameters":{"mode":"insert","tableName":{"__rl":true,"value":"revistas_inpi","mode":"list","cachedResultName":"revistas_inpi"},"options":{"queryName":"revistas_inpi"}},"type":"@n8n/n8n-nodes-langchain.vectorStoreSupabase","typeVersion":1.2,"position":[980,1380],"id":"f972cf6b-1a41-4f19-9f00-04a8125ea103","name":"Supabase Vector Store1","credentials":{"supabaseApi":{"id":"ZHIMmNbYxUlvBiKp","name":"teste-vector"}}},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[1040,1640],"id":"f9a2991e-882d-4b36-8194-d838b5c86532","name":"Embeddings OpenAI1","credentials":{"openAiApi":{"id":"bEHAhmQV1LUjIUXy","name":"OpenAi account"}}},{"parameters":{"dataType":"binary","binaryMode":"specificField","options":{}},"type":"@n8n/n8n-nodes-langchain.documentDefaultDataLoader","typeVersion":1,"position":[1160,1640],"id":"ce869a27-c1b7-4f13-ad2f-9b629197f683","name":"Default Data Loader1"},{"parameters":{},"type":"@n8n/n8n-nodes-langchain.textSplitterTokenSplitter","typeVersion":1,"position":[1240,1820],"id":"f1db29b4-3322-4e12-884c-38537efb29af","name":"Token Splitter1"},{"parameters":{"jsCode":"// Código para converter XML para PDF preservando todas as tags\nconst items = $input.all();\nconst outputItems = [];\n\n// Função para criar PDF preservando estrutura XML completa\nfunction createPdfWithXmlStructure(xmlContent) {\n  try {\n    // Função para formatar XML mantendo todas as tags visíveis\n    const formatXmlForPdf = (xmlString) => {\n      // Limpar apenas espaços desnecessários, mantendo toda estrutura\n      let formatted = xmlString\n        .replace(/>\\s+</g, '>\\n<') // Quebra linha entre tags\n        .replace(/^\\s+|\\s+$/gm, '') // Remove espaços das bordas\n        .split('\\n')\n        .map((line, index) => {\n          // Calcular indentação baseada no nível de aninhamento\n          const openTags = (line.match(/</g) || []).length;\n          const closeTags = (line.match(/\\//g) || []).length;\n          const depth = Math.max(0, (line.match(/<(?!\\/)/g) || []).length - closeTags);\n          const indent = '  '.repeat(depth);\n          \n          return line.trim() ? `${String(index + 1).padStart(4, ' ')}: ${indent}${line.trim()}` : '';\n        })\n        .filter(line => line.trim())\n        .join('\\n');\n      \n      return formatted;\n    };\n    \n    const formattedXml = formatXmlForPdf(xmlContent);\n    const pdfBuffer = generatePdfWithXmlContent(formattedXml, xmlContent);\n    \n    return pdfBuffer;\n    \n  } catch (error) {\n    throw new Error(`Erro ao processar XML: ${error.message}`);\n  }\n}\n\n// Gerar PDF com conteúdo XML estruturado\nfunction generatePdfWithXmlContent(formattedText, originalXml) {\n  const lines = formattedText.split('\\n');\n  const maxLinesPerPage = 45; // Menos linhas para dar espaço ao cabeçalho\n  const pages = [];\n  \n  // Dividir em páginas\n  for (let i = 0; i < lines.length; i += maxLinesPerPage) {\n    pages.push(lines.slice(i, i + maxLinesPerPage));\n  }\n  \n  let pdfObjects = [];\n  let objectId = 1;\n  \n  // Objeto 1: Catálogo\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Catalog /Pages 2 0 R >>`\n  });\n  \n  // Objeto 2: Páginas pai\n  const pageRefs = pages.map((_, index) => `${3 + index * 2} 0 R`).join(' ');\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Pages /Kids [${pageRefs}] /Count ${pages.length} >>`\n  });\n  \n  // Criar páginas com conteúdo XML\n  pages.forEach((pageLines, pageIndex) => {\n    const pageId = objectId++;\n    const contentId = objectId++;\n    \n    // Objeto da página\n    pdfObjects.push({\n      id: pageId,\n      content: `<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents ${contentId} 0 R /Resources << /Font << /F1 << /Type /Font /Subtype /Type1 /BaseFont /Courier >> /F2 << /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >> >> >> >>`\n    });\n    \n    // Preparar conteúdo da página com cabeçalho\n    let streamContent = 'BT\\n';\n    \n    // Cabeçalho da página\n    streamContent += '/F2 12 Tf 50 750 Td\\n';\n    streamContent += `(Estrutura XML - Página ${pageIndex + 1} de ${pages.length}) Tj\\n`;\n    streamContent += '0 -20 Td\\n';\n    streamContent += '/F1 8 Tf\\n';\n    streamContent += `(Preservando todas as tags XML para indexação RAG) Tj\\n`;\n    streamContent += '0 -15 Td\\n';\n    streamContent += '(____________________________________________________________) Tj\\n';\n    streamContent += '0 -20 Td\\n';\n    \n    // Conteúdo XML\n    streamContent += '/F1 9 Tf\\n';\n    streamContent += '10 TL\\n'; // Line leading\n    \n    pageLines.forEach(line => {\n      // Escapar caracteres especiais do PDF\n      const escapedLine = line\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\(/g, '\\\\(')\n        .replace(/\\)/g, '\\\\)')\n        .replace(/\\r/g, '')\n        .substring(0, 85); // Limitar tamanho da linha\n      \n      streamContent += `(${escapedLine}) Tj T*\\n`;\n    });\n    \n    streamContent += 'ET';\n    \n    // Objeto de conteúdo\n    pdfObjects.push({\n      id: contentId,\n      content: `<< /Length ${streamContent.length} >>\\nstream\\n${streamContent}\\nendstream`\n    });\n  });\n  \n  // Montar PDF final\n  let pdf = '%PDF-1.4\\n';\n  let xrefTable = [];\n  \n  // Adicionar objetos\n  pdfObjects.forEach(obj => {\n    xrefTable.push(pdf.length);\n    pdf += `${obj.id} 0 obj\\n${obj.content}\\nendobj\\n`;\n  });\n  \n  // Tabela xref\n  const xrefPos = pdf.length;\n  pdf += 'xref\\n';\n  pdf += `0 ${pdfObjects.length + 1}\\n`;\n  pdf += '0000000000 65535 f \\n';\n  \n  xrefTable.forEach(pos => {\n    pdf += pos.toString().padStart(10, '0') + ' 00000 n \\n';\n  });\n  \n  // Trailer\n  pdf += 'trailer\\n';\n  pdf += `<< /Size ${pdfObjects.length + 1} /Root 1 0 R >>\\n`;\n  pdf += 'startxref\\n';\n  pdf += xrefPos + '\\n';\n  pdf += '%%EOF\\n';\n  \n  return Buffer.from(pdf, 'utf8');\n}\n\n// Processar todos os items\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  try {\n    // Extrair conteúdo XML\n    let xmlContent = '';\n    \n    if (item.json && item.json.data) {\n      xmlContent = item.json.data;\n    } else if (item.binary && item.binary.data && item.binary.data.data) {\n      xmlContent = Buffer.from(item.binary.data.data, 'base64').toString('utf8');\n    }\n    \n    if (!xmlContent || xmlContent.trim() === '') {\n      throw new Error('Conteúdo XML não encontrado ou vazio');\n    }\n    \n    console.log(`Processando XML com ${xmlContent.length} caracteres`);\n    \n    // Converter para PDF preservando estrutura\n    const pdfBuffer = createPdfWithXmlStructure(xmlContent);\n    \n    // Preparar dados para RAG (manter XML original + PDF)\n    const outputItem = {\n      json: {\n        // Dados para o RAG\n        originalXml: xmlContent, // XML original completo para indexação\n        fileName: `xml_structured_${Date.now()}.pdf`,\n        mimeType: 'application/pdf',\n        fileSize: pdfBuffer.length,\n        xmlSize: xmlContent.length,\n        processingDate: new Date().toISOString(),\n        tags: extractXmlTags(xmlContent), // Extrair tags para facilitar busca\n        success: true\n      },\n      binary: {\n        data: {\n          data: pdfBuffer.toString('base64'),\n          mimeType: 'application/pdf',\n          fileName: `xml_structured_${Date.now()}.pdf`,\n          fileExtension: 'pdf'\n        }\n      }\n    };\n    \n    outputItems.push(outputItem);\n    \n  } catch (error) {\n    console.error(`Erro no item ${i}:`, error);\n    \n    outputItems.push({\n      json: {\n        error: error.message,\n        itemIndex: i,\n        success: false,\n        processingDate: new Date().toISOString()\n      }\n    });\n  }\n}\n\n// Função auxiliar para extrair tags XML para indexação\nfunction extractXmlTags(xmlContent) {\n  try {\n    const tagMatches = xmlContent.match(/<[^>]+>/g) || [];\n    const uniqueTags = [...new Set(tagMatches.map(tag => {\n      return tag.replace(/[<>\\/]/g, '').split(' ')[0];\n    }))];\n    return uniqueTags.filter(tag => tag.length > 0);\n  } catch (error) {\n    return [];\n  }\n}\n\nreturn outputItems;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[720,1380],"id":"3b69f8bb-d792-49c3-8ab9-6cc34f55d0a1","name":"Code1"},{"parameters":{"resource":"fileFolder","limit":2,"filter":{"folderId":{"__rl":true,"value":"1os3vZhfnEsUfMYFDchwNcw51NzGTtE-I","mode":"list","cachedResultName":"REVISTAS_INPI","cachedResultUrl":"https://drive.google.com/drive/folders/1os3vZhfnEsUfMYFDchwNcw51NzGTtE-I"}},"options":{"fields":["id"]}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[-20,1280],"id":"00c18a43-2a3a-4a7c-a23d-bb75f76768f2","name":"Google Drive","credentials":{"googleDriveOAuth2Api":{"id":"UMUzXd6peuAPf6IA","name":"Google Drive account"}}},{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[-260,1280],"id":"fe660bd7-94d1-4ad5-a9d0-f887a71eb62b","name":"When clicking ‘Execute workflow’"},{"parameters":{"options":{}},"type":"n8n-nodes-base.splitInBatches","typeVersion":3,"position":[240,1300],"id":"8f517ae8-01d3-4615-90cb-1fb922d63978","name":"Loop Over Items"},{"parameters":{"operation":"download","fileId":{"__rl":true,"value":"={{ $json.id }}","mode":"id"},"options":{}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[460,1380],"id":"0a18cd1e-c588-4e77-ae66-23c2f3dde789","name":"Google Drive1","credentials":{"googleDriveOAuth2Api":{"id":"UMUzXd6peuAPf6IA","name":"Google Drive account"}}},{"parameters":{"operation":"move","fileId":{"__rl":true,"value":"={{ $('Google Drive1').item.json.id }}","mode":"id"},"driveId":{"__rl":true,"mode":"list","value":"My Drive"},"folderId":{"__rl":true,"value":"1L5LA8fk_-7Epcf5B70GSzWq6eHWv6I_p","mode":"list","cachedResultName":"PROCESSADOS","cachedResultUrl":"https://drive.google.com/drive/folders/1L5LA8fk_-7Epcf5B70GSzWq6eHWv6I_p"}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[1740,1800],"id":"2342ee04-945a-4617-acb1-6e8439f15676","name":"Google Drive2","credentials":{"googleDriveOAuth2Api":{"id":"UMUzXd6peuAPf6IA","name":"Google Drive account"}}},{"parameters":{"content":"# ENVIANDO DOCUMETOS VIA INTERFACE","height":900,"width":1540},"type":"n8n-nodes-base.stickyNote","position":[-340,-240],"typeVersion":1,"id":"5cea7970-f6c7-481a-bd7c-913ac7b0f8c1","name":"Sticky Note"}],"connections":{"HTML":{"main":[[{"node":"Respond to Webhook","type":"main","index":0}]]},"Supabase Vector Store":{"ai_tool":[[]]},"Embeddings OpenAI":{"ai_embedding":[[{"node":"Supabase Vector Store","type":"ai_embedding","index":0}]]},"Default Data Loader":{"ai_document":[[{"node":"Supabase Vector Store","type":"ai_document","index":0}]]},"Token Splitter":{"ai_textSplitter":[[{"node":"Default Data Loader","type":"ai_textSplitter","index":0}]]},"Webhook1":{"main":[[{"node":"Extract from File","type":"main","index":0}]]},"Webhook":{"main":[[{"node":"HTML","type":"main","index":0}]]},"Extract from File":{"main":[[{"node":"Convert to File","type":"main","index":0}]]},"Convert to File":{"main":[[{"node":"Code","type":"main","index":0}]]},"Code":{"main":[[{"node":"Supabase Vector Store","type":"main","index":0}]]},"Embeddings OpenAI1":{"ai_embedding":[[{"node":"Supabase Vector Store1","type":"ai_embedding","index":0}]]},"Default Data Loader1":{"ai_document":[[{"node":"Supabase Vector Store1","type":"ai_document","index":0}]]},"Token Splitter1":{"ai_textSplitter":[[{"node":"Default Data Loader1","type":"ai_textSplitter","index":0}]]},"Code1":{"main":[[{"node":"Supabase Vector Store1","type":"main","index":0}]]},"When clicking ‘Execute workflow’":{"main":[[{"node":"Google Drive","type":"main","index":0}]]},"Google Drive":{"main":[[{"node":"Loop Over Items","type":"main","index":0}]]},"Loop Over Items":{"main":[[],[{"node":"Google Drive1","type":"main","index":0}]]},"Google Drive1":{"main":[[{"node":"Code1","type":"main","index":0}]]},"Supabase Vector Store1":{"main":[[{"node":"Google Drive2","type":"main","index":0}]]},"Google Drive2":{"main":[[{"node":"Loop Over Items","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"915a08df-2703-46ed-a8a7-3c17c6a2950c","activeVersionId":"915a08df-2703-46ed-a8a7-3c17c6a2950c","triggerCount":2,"shared":[{"updatedAt":"2025-06-23T12:23:52.966Z","createdAt":"2025-06-23T12:23:52.966Z","role":"workflow:owner","workflowId":"oFzkFeBXFJzl27GT","projectId":"BlSED80HESP48veq"}],"activeVersion":{"updatedAt":"2025-12-01T11:56:54.083Z","createdAt":"2025-12-01T11:56:54.083Z","versionId":"915a08df-2703-46ed-a8a7-3c17c6a2950c","workflowId":"oFzkFeBXFJzl27GT","nodes":[{"parameters":{"html":"<!DOCTYPE html>\n<html lang=\"pt-BR\">\n<head>\n   <meta charset=\"UTF-8\">\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   <title>Document Upload</title>\n   <script src=\"https://cdn.tailwindcss.com\"></script>\n</head>\n<body>\n   <div class=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n       <div class=\"bg-white rounded-lg shadow-lg border border-gray-200 p-8 w-full max-w-md\">\n           <div class=\"text-center mb-6\">\n               <div class=\"w-12 h-12 bg-green-500 rounded-md flex items-center justify-center mx-auto mb-4\">\n                   <svg class=\"w-6 h-6 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                       <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n                   </svg>\n               </div>\n               <h1 class=\"text-xl font-semibold text-gray-900\">Upload Document AGENT CREATOR CONTENT</h1>\n               <p class=\"text-sm text-gray-500\">PDF, DOC, DOCX, TXT, MD, XML</p>\n           </div>\n\n           <form id=\"uploadForm\" class=\"space-y-4\">\n               <div>\n                   <input \n                       type=\"file\" \n                       id=\"fileInput\" \n                       accept=\".pdf,.doc,.docx,.txt,.md, .xml\"\n                       class=\"block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100\"\n                       required\n                   />\n               </div>\n               \n               <button \n                   type=\"submit\" \n                   id=\"uploadBtn\"\n                   class=\"w-full bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-md transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed\"\n               >\n                   Upload Document\n               </button>\n           </form>\n\n           <!-- Status message -->\n           <div id=\"statusMessage\" class=\"mt-4 hidden\"></div>\n       </div>\n   </div>\n\n   <script>\n       const form = document.getElementById('uploadForm');\n       const fileInput = document.getElementById('fileInput');\n       const uploadBtn = document.getElementById('uploadBtn');\n       const statusMessage = document.getElementById('statusMessage');\n       const webhookUrl = 'https://primary-production-70c40.up.railway.app/webhook-test/7bcfb3a8-c514-42bd-9f80-cb1ede1a3d64';\n\n       form.addEventListener('submit', async (e) => {\n           e.preventDefault();\n           \n           const file = fileInput.files[0];\n           if (!file) {\n               showMessage('Please select a file', 'error');\n               return;\n           }\n\n           // Validate file\n           if (!validateFile(file)) {\n               return;\n           }\n\n           // Disable button and show loading\n           uploadBtn.disabled = true;\n           uploadBtn.textContent = 'Uploading...';\n           showMessage('Uploading document...', 'loading');\n\n           try {\n               const formData = new FormData();\n               formData.append('file', file);\n\n               const response = await fetch(webhookUrl, {\n                   method: 'POST',\n                   body: formData\n               });\n\n               if (response.ok) {\n                   showMessage('Document uploaded successfully!', 'success');\n                   form.reset();\n               } else {\n                   throw new Error(`Upload failed: ${response.status}`);\n               }\n           } catch (error) {\n               console.error('Upload error:', error);\n               showMessage('Upload failed. Please try again.', 'error');\n           } finally {\n               uploadBtn.disabled = false;\n               uploadBtn.textContent = 'Upload Document';\n           }\n       });\n\n       function validateFile(file) {\n          const allowedTypes = [\n              'application/pdf',\n              'application/msword',\n              'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n              'text/plain',\n              'text/markdown',\n              'application/xml',\n              'text/xml',\n              'application/xhtml+xml'\n          ];\n           \n           const maxSize = 50 * 1024 * 1024; // 10MB\n\n           if (!allowedTypes.includes(file.type)) {\n               showMessage('File type not supported: ' + file.name, 'error');\n               return false;\n           }\n\n           if (file.size > maxSize) {\n               showMessage('File too large: ' + file.name + '. Maximum 10MB.', 'error');\n               return false;\n           }\n\n           return true;\n       }\n\n       function showMessage(message, type) {\n           statusMessage.className = 'mt-4 p-3 rounded-md text-sm';\n           statusMessage.classList.remove('hidden');\n           \n           switch (type) {\n               case 'success':\n                   statusMessage.className += ' bg-green-100 text-green-800 border border-green-200';\n                   break;\n               case 'error':\n                   statusMessage.className += ' bg-red-100 text-red-800 border border-red-200';\n                   break;\n               case 'loading':\n                   statusMessage.className += ' bg-blue-100 text-blue-800 border border-blue-200';\n                   break;\n           }\n           \n           statusMessage.textContent = message;\n       }\n   </script>\n</body>\n</html>"},"type":"n8n-nodes-base.html","typeVersion":1.2,"position":[-40,-100],"id":"83ca966c-e2e6-484e-85a5-148f3cbaf0a7","name":"HTML"},{"parameters":{"respondWith":"text","responseBody":"={{ $json.html }}","options":{}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.3,"position":[180,-100],"id":"269a324a-a706-4817-8389-1bc5c6a79dac","name":"Respond to Webhook"},{"parameters":{"mode":"insert","tableName":{"__rl":true,"value":"revistas_inpi","mode":"list","cachedResultName":"revistas_inpi"},"options":{"queryName":"revistas_inpi"}},"type":"@n8n/n8n-nodes-langchain.vectorStoreSupabase","typeVersion":1.2,"position":[680,100],"id":"c8e1e51c-30f8-4a1e-90c9-7f6299af1295","name":"Supabase Vector Store","credentials":{"supabaseApi":{"id":"ZHIMmNbYxUlvBiKp","name":"teste-vector"}}},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[680,320],"id":"383a39ca-ee6f-4fc9-ba39-e8e6113f9473","name":"Embeddings OpenAI","credentials":{"openAiApi":{"id":"bEHAhmQV1LUjIUXy","name":"OpenAi account"}}},{"parameters":{"dataType":"binary","binaryMode":"specificField","options":{}},"type":"@n8n/n8n-nodes-langchain.documentDefaultDataLoader","typeVersion":1,"position":[800,320],"id":"ff261255-2d5c-4f1f-880c-0375a93856b6","name":"Default Data Loader"},{"parameters":{},"type":"@n8n/n8n-nodes-langchain.textSplitterTokenSplitter","typeVersion":1,"position":[880,500],"id":"416ca37f-3384-447b-aa8a-56afb192d876","name":"Token Splitter"},{"parameters":{"httpMethod":"POST","path":"7bcfb3a8-c514-42bd-9f80-cb1ede1a3d64","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2,"position":[-260,100],"id":"dd59c65b-60dc-4a34-a6d6-2bcaae9a65e1","name":"Webhook1","webhookId":"7bcfb3a8-c514-42bd-9f80-cb1ede1a3d64"},{"parameters":{"path":"c35cc5ef-5a69-4c44-a0b4-4c19473a5c73","responseMode":"responseNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2,"position":[-260,-100],"id":"4653feba-c2d0-444f-81f5-7daf6901714c","name":"Webhook","webhookId":"c35cc5ef-5a69-4c44-a0b4-4c19473a5c73"},{"parameters":{"operation":"binaryToPropery","binaryPropertyName":"file","options":{}},"type":"n8n-nodes-base.extractFromFile","typeVersion":1,"position":[-40,100],"id":"c773de41-1c94-4253-8276-5ae39d40b83b","name":"Extract from File"},{"parameters":{"operation":"toBinary","sourceProperty":"data","options":{}},"type":"n8n-nodes-base.convertToFile","typeVersion":1.1,"position":[180,100],"id":"2181fab0-0777-4459-939d-9c7c2616b5b5","name":"Convert to File"},{"parameters":{"jsCode":"// Código para converter XML para PDF preservando todas as tags\nconst items = $input.all();\nconst outputItems = [];\n\n// Função para criar PDF preservando estrutura XML completa\nfunction createPdfWithXmlStructure(xmlContent) {\n  try {\n    // Função para formatar XML mantendo todas as tags visíveis\n    const formatXmlForPdf = (xmlString) => {\n      // Limpar apenas espaços desnecessários, mantendo toda estrutura\n      let formatted = xmlString\n        .replace(/>\\s+</g, '>\\n<') // Quebra linha entre tags\n        .replace(/^\\s+|\\s+$/gm, '') // Remove espaços das bordas\n        .split('\\n')\n        .map((line, index) => {\n          // Calcular indentação baseada no nível de aninhamento\n          const openTags = (line.match(/</g) || []).length;\n          const closeTags = (line.match(/\\//g) || []).length;\n          const depth = Math.max(0, (line.match(/<(?!\\/)/g) || []).length - closeTags);\n          const indent = '  '.repeat(depth);\n          \n          return line.trim() ? `${String(index + 1).padStart(4, ' ')}: ${indent}${line.trim()}` : '';\n        })\n        .filter(line => line.trim())\n        .join('\\n');\n      \n      return formatted;\n    };\n    \n    const formattedXml = formatXmlForPdf(xmlContent);\n    const pdfBuffer = generatePdfWithXmlContent(formattedXml, xmlContent);\n    \n    return pdfBuffer;\n    \n  } catch (error) {\n    throw new Error(`Erro ao processar XML: ${error.message}`);\n  }\n}\n\n// Gerar PDF com conteúdo XML estruturado\nfunction generatePdfWithXmlContent(formattedText, originalXml) {\n  const lines = formattedText.split('\\n');\n  const maxLinesPerPage = 45; // Menos linhas para dar espaço ao cabeçalho\n  const pages = [];\n  \n  // Dividir em páginas\n  for (let i = 0; i < lines.length; i += maxLinesPerPage) {\n    pages.push(lines.slice(i, i + maxLinesPerPage));\n  }\n  \n  let pdfObjects = [];\n  let objectId = 1;\n  \n  // Objeto 1: Catálogo\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Catalog /Pages 2 0 R >>`\n  });\n  \n  // Objeto 2: Páginas pai\n  const pageRefs = pages.map((_, index) => `${3 + index * 2} 0 R`).join(' ');\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Pages /Kids [${pageRefs}] /Count ${pages.length} >>`\n  });\n  \n  // Criar páginas com conteúdo XML\n  pages.forEach((pageLines, pageIndex) => {\n    const pageId = objectId++;\n    const contentId = objectId++;\n    \n    // Objeto da página\n    pdfObjects.push({\n      id: pageId,\n      content: `<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents ${contentId} 0 R /Resources << /Font << /F1 << /Type /Font /Subtype /Type1 /BaseFont /Courier >> /F2 << /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >> >> >> >>`\n    });\n    \n    // Preparar conteúdo da página com cabeçalho\n    let streamContent = 'BT\\n';\n    \n    // Cabeçalho da página\n    streamContent += '/F2 12 Tf 50 750 Td\\n';\n    streamContent += `(Estrutura XML - Página ${pageIndex + 1} de ${pages.length}) Tj\\n`;\n    streamContent += '0 -20 Td\\n';\n    streamContent += '/F1 8 Tf\\n';\n    streamContent += `(Preservando todas as tags XML para indexação RAG) Tj\\n`;\n    streamContent += '0 -15 Td\\n';\n    streamContent += '(____________________________________________________________) Tj\\n';\n    streamContent += '0 -20 Td\\n';\n    \n    // Conteúdo XML\n    streamContent += '/F1 9 Tf\\n';\n    streamContent += '10 TL\\n'; // Line leading\n    \n    pageLines.forEach(line => {\n      // Escapar caracteres especiais do PDF\n      const escapedLine = line\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\(/g, '\\\\(')\n        .replace(/\\)/g, '\\\\)')\n        .replace(/\\r/g, '')\n        .substring(0, 85); // Limitar tamanho da linha\n      \n      streamContent += `(${escapedLine}) Tj T*\\n`;\n    });\n    \n    streamContent += 'ET';\n    \n    // Objeto de conteúdo\n    pdfObjects.push({\n      id: contentId,\n      content: `<< /Length ${streamContent.length} >>\\nstream\\n${streamContent}\\nendstream`\n    });\n  });\n  \n  // Montar PDF final\n  let pdf = '%PDF-1.4\\n';\n  let xrefTable = [];\n  \n  // Adicionar objetos\n  pdfObjects.forEach(obj => {\n    xrefTable.push(pdf.length);\n    pdf += `${obj.id} 0 obj\\n${obj.content}\\nendobj\\n`;\n  });\n  \n  // Tabela xref\n  const xrefPos = pdf.length;\n  pdf += 'xref\\n';\n  pdf += `0 ${pdfObjects.length + 1}\\n`;\n  pdf += '0000000000 65535 f \\n';\n  \n  xrefTable.forEach(pos => {\n    pdf += pos.toString().padStart(10, '0') + ' 00000 n \\n';\n  });\n  \n  // Trailer\n  pdf += 'trailer\\n';\n  pdf += `<< /Size ${pdfObjects.length + 1} /Root 1 0 R >>\\n`;\n  pdf += 'startxref\\n';\n  pdf += xrefPos + '\\n';\n  pdf += '%%EOF\\n';\n  \n  return Buffer.from(pdf, 'utf8');\n}\n\n// Processar todos os items\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  try {\n    // Extrair conteúdo XML\n    let xmlContent = '';\n    \n    if (item.json && item.json.data) {\n      xmlContent = item.json.data;\n    } else if (item.binary && item.binary.data && item.binary.data.data) {\n      xmlContent = Buffer.from(item.binary.data.data, 'base64').toString('utf8');\n    }\n    \n    if (!xmlContent || xmlContent.trim() === '') {\n      throw new Error('Conteúdo XML não encontrado ou vazio');\n    }\n    \n    console.log(`Processando XML com ${xmlContent.length} caracteres`);\n    \n    // Converter para PDF preservando estrutura\n    const pdfBuffer = createPdfWithXmlStructure(xmlContent);\n    \n    // Preparar dados para RAG (manter XML original + PDF)\n    const outputItem = {\n      json: {\n        // Dados para o RAG\n        originalXml: xmlContent, // XML original completo para indexação\n        fileName: `xml_structured_${Date.now()}.pdf`,\n        mimeType: 'application/pdf',\n        fileSize: pdfBuffer.length,\n        xmlSize: xmlContent.length,\n        processingDate: new Date().toISOString(),\n        tags: extractXmlTags(xmlContent), // Extrair tags para facilitar busca\n        success: true\n      },\n      binary: {\n        data: {\n          data: pdfBuffer.toString('base64'),\n          mimeType: 'application/pdf',\n          fileName: `xml_structured_${Date.now()}.pdf`,\n          fileExtension: 'pdf'\n        }\n      }\n    };\n    \n    outputItems.push(outputItem);\n    \n  } catch (error) {\n    console.error(`Erro no item ${i}:`, error);\n    \n    outputItems.push({\n      json: {\n        error: error.message,\n        itemIndex: i,\n        success: false,\n        processingDate: new Date().toISOString()\n      }\n    });\n  }\n}\n\n// Função auxiliar para extrair tags XML para indexação\nfunction extractXmlTags(xmlContent) {\n  try {\n    const tagMatches = xmlContent.match(/<[^>]+>/g) || [];\n    const uniqueTags = [...new Set(tagMatches.map(tag => {\n      return tag.replace(/[<>\\/]/g, '').split(' ')[0];\n    }))];\n    return uniqueTags.filter(tag => tag.length > 0);\n  } catch (error) {\n    return [];\n  }\n}\n\nreturn outputItems;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[420,100],"id":"a252e8ff-c66c-4c95-9d41-171d858f08af","name":"Code"},{"parameters":{"mode":"insert","tableName":{"__rl":true,"value":"revistas_inpi","mode":"list","cachedResultName":"revistas_inpi"},"options":{"queryName":"revistas_inpi"}},"type":"@n8n/n8n-nodes-langchain.vectorStoreSupabase","typeVersion":1.2,"position":[980,1380],"id":"f972cf6b-1a41-4f19-9f00-04a8125ea103","name":"Supabase Vector Store1","credentials":{"supabaseApi":{"id":"ZHIMmNbYxUlvBiKp","name":"teste-vector"}}},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[1040,1640],"id":"f9a2991e-882d-4b36-8194-d838b5c86532","name":"Embeddings OpenAI1","credentials":{"openAiApi":{"id":"bEHAhmQV1LUjIUXy","name":"OpenAi account"}}},{"parameters":{"dataType":"binary","binaryMode":"specificField","options":{}},"type":"@n8n/n8n-nodes-langchain.documentDefaultDataLoader","typeVersion":1,"position":[1160,1640],"id":"ce869a27-c1b7-4f13-ad2f-9b629197f683","name":"Default Data Loader1"},{"parameters":{},"type":"@n8n/n8n-nodes-langchain.textSplitterTokenSplitter","typeVersion":1,"position":[1240,1820],"id":"f1db29b4-3322-4e12-884c-38537efb29af","name":"Token Splitter1"},{"parameters":{"jsCode":"// Código para converter XML para PDF preservando todas as tags\nconst items = $input.all();\nconst outputItems = [];\n\n// Função para criar PDF preservando estrutura XML completa\nfunction createPdfWithXmlStructure(xmlContent) {\n  try {\n    // Função para formatar XML mantendo todas as tags visíveis\n    const formatXmlForPdf = (xmlString) => {\n      // Limpar apenas espaços desnecessários, mantendo toda estrutura\n      let formatted = xmlString\n        .replace(/>\\s+</g, '>\\n<') // Quebra linha entre tags\n        .replace(/^\\s+|\\s+$/gm, '') // Remove espaços das bordas\n        .split('\\n')\n        .map((line, index) => {\n          // Calcular indentação baseada no nível de aninhamento\n          const openTags = (line.match(/</g) || []).length;\n          const closeTags = (line.match(/\\//g) || []).length;\n          const depth = Math.max(0, (line.match(/<(?!\\/)/g) || []).length - closeTags);\n          const indent = '  '.repeat(depth);\n          \n          return line.trim() ? `${String(index + 1).padStart(4, ' ')}: ${indent}${line.trim()}` : '';\n        })\n        .filter(line => line.trim())\n        .join('\\n');\n      \n      return formatted;\n    };\n    \n    const formattedXml = formatXmlForPdf(xmlContent);\n    const pdfBuffer = generatePdfWithXmlContent(formattedXml, xmlContent);\n    \n    return pdfBuffer;\n    \n  } catch (error) {\n    throw new Error(`Erro ao processar XML: ${error.message}`);\n  }\n}\n\n// Gerar PDF com conteúdo XML estruturado\nfunction generatePdfWithXmlContent(formattedText, originalXml) {\n  const lines = formattedText.split('\\n');\n  const maxLinesPerPage = 45; // Menos linhas para dar espaço ao cabeçalho\n  const pages = [];\n  \n  // Dividir em páginas\n  for (let i = 0; i < lines.length; i += maxLinesPerPage) {\n    pages.push(lines.slice(i, i + maxLinesPerPage));\n  }\n  \n  let pdfObjects = [];\n  let objectId = 1;\n  \n  // Objeto 1: Catálogo\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Catalog /Pages 2 0 R >>`\n  });\n  \n  // Objeto 2: Páginas pai\n  const pageRefs = pages.map((_, index) => `${3 + index * 2} 0 R`).join(' ');\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Pages /Kids [${pageRefs}] /Count ${pages.length} >>`\n  });\n  \n  // Criar páginas com conteúdo XML\n  pages.forEach((pageLines, pageIndex) => {\n    const pageId = objectId++;\n    const contentId = objectId++;\n    \n    // Objeto da página\n    pdfObjects.push({\n      id: pageId,\n      content: `<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents ${contentId} 0 R /Resources << /Font << /F1 << /Type /Font /Subtype /Type1 /BaseFont /Courier >> /F2 << /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >> >> >> >>`\n    });\n    \n    // Preparar conteúdo da página com cabeçalho\n    let streamContent = 'BT\\n';\n    \n    // Cabeçalho da página\n    streamContent += '/F2 12 Tf 50 750 Td\\n';\n    streamContent += `(Estrutura XML - Página ${pageIndex + 1} de ${pages.length}) Tj\\n`;\n    streamContent += '0 -20 Td\\n';\n    streamContent += '/F1 8 Tf\\n';\n    streamContent += `(Preservando todas as tags XML para indexação RAG) Tj\\n`;\n    streamContent += '0 -15 Td\\n';\n    streamContent += '(____________________________________________________________) Tj\\n';\n    streamContent += '0 -20 Td\\n';\n    \n    // Conteúdo XML\n    streamContent += '/F1 9 Tf\\n';\n    streamContent += '10 TL\\n'; // Line leading\n    \n    pageLines.forEach(line => {\n      // Escapar caracteres especiais do PDF\n      const escapedLine = line\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\(/g, '\\\\(')\n        .replace(/\\)/g, '\\\\)')\n        .replace(/\\r/g, '')\n        .substring(0, 85); // Limitar tamanho da linha\n      \n      streamContent += `(${escapedLine}) Tj T*\\n`;\n    });\n    \n    streamContent += 'ET';\n    \n    // Objeto de conteúdo\n    pdfObjects.push({\n      id: contentId,\n      content: `<< /Length ${streamContent.length} >>\\nstream\\n${streamContent}\\nendstream`\n    });\n  });\n  \n  // Montar PDF final\n  let pdf = '%PDF-1.4\\n';\n  let xrefTable = [];\n  \n  // Adicionar objetos\n  pdfObjects.forEach(obj => {\n    xrefTable.push(pdf.length);\n    pdf += `${obj.id} 0 obj\\n${obj.content}\\nendobj\\n`;\n  });\n  \n  // Tabela xref\n  const xrefPos = pdf.length;\n  pdf += 'xref\\n';\n  pdf += `0 ${pdfObjects.length + 1}\\n`;\n  pdf += '0000000000 65535 f \\n';\n  \n  xrefTable.forEach(pos => {\n    pdf += pos.toString().padStart(10, '0') + ' 00000 n \\n';\n  });\n  \n  // Trailer\n  pdf += 'trailer\\n';\n  pdf += `<< /Size ${pdfObjects.length + 1} /Root 1 0 R >>\\n`;\n  pdf += 'startxref\\n';\n  pdf += xrefPos + '\\n';\n  pdf += '%%EOF\\n';\n  \n  return Buffer.from(pdf, 'utf8');\n}\n\n// Processar todos os items\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  try {\n    // Extrair conteúdo XML\n    let xmlContent = '';\n    \n    if (item.json && item.json.data) {\n      xmlContent = item.json.data;\n    } else if (item.binary && item.binary.data && item.binary.data.data) {\n      xmlContent = Buffer.from(item.binary.data.data, 'base64').toString('utf8');\n    }\n    \n    if (!xmlContent || xmlContent.trim() === '') {\n      throw new Error('Conteúdo XML não encontrado ou vazio');\n    }\n    \n    console.log(`Processando XML com ${xmlContent.length} caracteres`);\n    \n    // Converter para PDF preservando estrutura\n    const pdfBuffer = createPdfWithXmlStructure(xmlContent);\n    \n    // Preparar dados para RAG (manter XML original + PDF)\n    const outputItem = {\n      json: {\n        // Dados para o RAG\n        originalXml: xmlContent, // XML original completo para indexação\n        fileName: `xml_structured_${Date.now()}.pdf`,\n        mimeType: 'application/pdf',\n        fileSize: pdfBuffer.length,\n        xmlSize: xmlContent.length,\n        processingDate: new Date().toISOString(),\n        tags: extractXmlTags(xmlContent), // Extrair tags para facilitar busca\n        success: true\n      },\n      binary: {\n        data: {\n          data: pdfBuffer.toString('base64'),\n          mimeType: 'application/pdf',\n          fileName: `xml_structured_${Date.now()}.pdf`,\n          fileExtension: 'pdf'\n        }\n      }\n    };\n    \n    outputItems.push(outputItem);\n    \n  } catch (error) {\n    console.error(`Erro no item ${i}:`, error);\n    \n    outputItems.push({\n      json: {\n        error: error.message,\n        itemIndex: i,\n        success: false,\n        processingDate: new Date().toISOString()\n      }\n    });\n  }\n}\n\n// Função auxiliar para extrair tags XML para indexação\nfunction extractXmlTags(xmlContent) {\n  try {\n    const tagMatches = xmlContent.match(/<[^>]+>/g) || [];\n    const uniqueTags = [...new Set(tagMatches.map(tag => {\n      return tag.replace(/[<>\\/]/g, '').split(' ')[0];\n    }))];\n    return uniqueTags.filter(tag => tag.length > 0);\n  } catch (error) {\n    return [];\n  }\n}\n\nreturn outputItems;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[720,1380],"id":"3b69f8bb-d792-49c3-8ab9-6cc34f55d0a1","name":"Code1"},{"parameters":{"resource":"fileFolder","limit":2,"filter":{"folderId":{"__rl":true,"value":"1os3vZhfnEsUfMYFDchwNcw51NzGTtE-I","mode":"list","cachedResultName":"REVISTAS_INPI","cachedResultUrl":"https://drive.google.com/drive/folders/1os3vZhfnEsUfMYFDchwNcw51NzGTtE-I"}},"options":{"fields":["id"]}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[-20,1280],"id":"00c18a43-2a3a-4a7c-a23d-bb75f76768f2","name":"Google Drive","credentials":{"googleDriveOAuth2Api":{"id":"UMUzXd6peuAPf6IA","name":"Google Drive account"}}},{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[-260,1280],"id":"fe660bd7-94d1-4ad5-a9d0-f887a71eb62b","name":"When clicking ‘Execute workflow’"},{"parameters":{"options":{}},"type":"n8n-nodes-base.splitInBatches","typeVersion":3,"position":[240,1300],"id":"8f517ae8-01d3-4615-90cb-1fb922d63978","name":"Loop Over Items"},{"parameters":{"operation":"download","fileId":{"__rl":true,"value":"={{ $json.id }}","mode":"id"},"options":{}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[460,1380],"id":"0a18cd1e-c588-4e77-ae66-23c2f3dde789","name":"Google Drive1","credentials":{"googleDriveOAuth2Api":{"id":"UMUzXd6peuAPf6IA","name":"Google Drive account"}}},{"parameters":{"operation":"move","fileId":{"__rl":true,"value":"={{ $('Google Drive1').item.json.id }}","mode":"id"},"driveId":{"__rl":true,"mode":"list","value":"My Drive"},"folderId":{"__rl":true,"value":"1L5LA8fk_-7Epcf5B70GSzWq6eHWv6I_p","mode":"list","cachedResultName":"PROCESSADOS","cachedResultUrl":"https://drive.google.com/drive/folders/1L5LA8fk_-7Epcf5B70GSzWq6eHWv6I_p"}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[1740,1800],"id":"2342ee04-945a-4617-acb1-6e8439f15676","name":"Google Drive2","credentials":{"googleDriveOAuth2Api":{"id":"UMUzXd6peuAPf6IA","name":"Google Drive account"}}},{"parameters":{"content":"# ENVIANDO DOCUMETOS VIA INTERFACE","height":900,"width":1540},"type":"n8n-nodes-base.stickyNote","position":[-340,-240],"typeVersion":1,"id":"5cea7970-f6c7-481a-bd7c-913ac7b0f8c1","name":"Sticky Note"}],"connections":{"HTML":{"main":[[{"node":"Respond to Webhook","type":"main","index":0}]]},"Supabase Vector Store":{"ai_tool":[[]]},"Embeddings OpenAI":{"ai_embedding":[[{"node":"Supabase Vector Store","type":"ai_embedding","index":0}]]},"Default Data Loader":{"ai_document":[[{"node":"Supabase Vector Store","type":"ai_document","index":0}]]},"Token Splitter":{"ai_textSplitter":[[{"node":"Default Data Loader","type":"ai_textSplitter","index":0}]]},"Webhook1":{"main":[[{"node":"Extract from File","type":"main","index":0}]]},"Webhook":{"main":[[{"node":"HTML","type":"main","index":0}]]},"Extract from File":{"main":[[{"node":"Convert to File","type":"main","index":0}]]},"Convert to File":{"main":[[{"node":"Code","type":"main","index":0}]]},"Code":{"main":[[{"node":"Supabase Vector Store","type":"main","index":0}]]},"Embeddings OpenAI1":{"ai_embedding":[[{"node":"Supabase Vector Store1","type":"ai_embedding","index":0}]]},"Default Data Loader1":{"ai_document":[[{"node":"Supabase Vector Store1","type":"ai_document","index":0}]]},"Token Splitter1":{"ai_textSplitter":[[{"node":"Default Data Loader1","type":"ai_textSplitter","index":0}]]},"Code1":{"main":[[{"node":"Supabase Vector Store1","type":"main","index":0}]]},"When clicking ‘Execute workflow’":{"main":[[{"node":"Google Drive","type":"main","index":0}]]},"Google Drive":{"main":[[{"node":"Loop Over Items","type":"main","index":0}]]},"Loop Over Items":{"main":[[],[{"node":"Google Drive1","type":"main","index":0}]]},"Google Drive1":{"main":[[{"node":"Code1","type":"main","index":0}]]},"Supabase Vector Store1":{"main":[[{"node":"Google Drive2","type":"main","index":0}]]},"Google Drive2":{"main":[[{"node":"Loop Over Items","type":"main","index":0}]]}},"authors":"system migration","name":null,"description":null,"autosaved":false},"tags":[]}