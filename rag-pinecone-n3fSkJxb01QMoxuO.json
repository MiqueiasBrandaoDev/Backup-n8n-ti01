{"updatedAt":"2025-06-26T18:01:51.376Z","createdAt":"2025-06-24T15:04:40.879Z","id":"n3fSkJxb01QMoxuO","name":"RAG PINECONE","active":false,"isArchived":false,"nodes":[{"parameters":{"mode":"insert","pineconeIndex":{"__rl":true,"value":"inpi","mode":"list","cachedResultName":"inpi"},"options":{}},"type":"@n8n/n8n-nodes-langchain.vectorStorePinecone","typeVersion":1.3,"position":[880,460],"id":"8a843519-08a1-4c3e-b939-f4903338a440","name":"Pinecone Vector Store","credentials":{"pineconeApi":{"id":"tZGLab4uo4TJ4k4Y","name":"PineconeApi account"}}},{"parameters":{"html":"<!DOCTYPE html>\n<html lang=\"pt-BR\">\n<head>\n   <meta charset=\"UTF-8\">\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   <title>Document Upload</title>\n   <script src=\"https://cdn.tailwindcss.com\"></script>\n</head>\n<body>\n   <div class=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n       <div class=\"bg-white rounded-lg shadow-lg border border-gray-200 p-8 w-full max-w-md\">\n           <div class=\"text-center mb-6\">\n               <div class=\"w-12 h-12 bg-green-500 rounded-md flex items-center justify-center mx-auto mb-4\">\n                   <svg class=\"w-6 h-6 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                       <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n                   </svg>\n               </div>\n               <h1 class=\"text-xl font-semibold text-gray-900\">Upload Document AGENT CREATOR CONTENT</h1>\n               <p class=\"text-sm text-gray-500\">PDF, DOC, DOCX, TXT, MD, XML</p>\n           </div>\n\n           <form id=\"uploadForm\" class=\"space-y-4\">\n               <div>\n                   <input \n                       type=\"file\" \n                       id=\"fileInput\" \n                       accept=\".pdf,.doc,.docx,.txt,.md, .xml\"\n                       class=\"block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100\"\n                       required\n                   />\n               </div>\n               \n               <button \n                   type=\"submit\" \n                   id=\"uploadBtn\"\n                   class=\"w-full bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-md transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed\"\n               >\n                   Upload Document\n               </button>\n           </form>\n\n           <!-- Status message -->\n           <div id=\"statusMessage\" class=\"mt-4 hidden\"></div>\n       </div>\n   </div>\n\n   <script>\n       const form = document.getElementById('uploadForm');\n       const fileInput = document.getElementById('fileInput');\n       const uploadBtn = document.getElementById('uploadBtn');\n       const statusMessage = document.getElementById('statusMessage');\n       const webhookUrl = 'https://primary-production-70c40.up.railway.app/webhook-test/7bcfb3a8-c514-42bd-9f80-cb1ede1a3d64';\n\n       form.addEventListener('submit', async (e) => {\n           e.preventDefault();\n           \n           const file = fileInput.files[0];\n           if (!file) {\n               showMessage('Please select a file', 'error');\n               return;\n           }\n\n           // Validate file\n           if (!validateFile(file)) {\n               return;\n           }\n\n           // Disable button and show loading\n           uploadBtn.disabled = true;\n           uploadBtn.textContent = 'Uploading...';\n           showMessage('Uploading document...', 'loading');\n\n           try {\n               const formData = new FormData();\n               formData.append('file', file);\n\n               const response = await fetch(webhookUrl, {\n                   method: 'POST',\n                   body: formData\n               });\n\n               if (response.ok) {\n                   showMessage('Document uploaded successfully!', 'success');\n                   form.reset();\n               } else {\n                   throw new Error(`Upload failed: ${response.status}`);\n               }\n           } catch (error) {\n               console.error('Upload error:', error);\n               showMessage('Upload failed. Please try again.', 'error');\n           } finally {\n               uploadBtn.disabled = false;\n               uploadBtn.textContent = 'Upload Document';\n           }\n       });\n\n       function validateFile(file) {\n          const allowedTypes = [\n              'application/pdf',\n              'application/msword',\n              'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n              'text/plain',\n              'text/markdown',\n              'application/xml',\n              'text/xml',\n              'application/xhtml+xml'\n          ];\n           \n           const maxSize = 50 * 1024 * 1024; // 10MB\n\n           if (!allowedTypes.includes(file.type)) {\n               showMessage('File type not supported: ' + file.name, 'error');\n               return false;\n           }\n\n           if (file.size > maxSize) {\n               showMessage('File too large: ' + file.name + '. Maximum 10MB.', 'error');\n               return false;\n           }\n\n           return true;\n       }\n\n       function showMessage(message, type) {\n           statusMessage.className = 'mt-4 p-3 rounded-md text-sm';\n           statusMessage.classList.remove('hidden');\n           \n           switch (type) {\n               case 'success':\n                   statusMessage.className += ' bg-green-100 text-green-800 border border-green-200';\n                   break;\n               case 'error':\n                   statusMessage.className += ' bg-red-100 text-red-800 border border-red-200';\n                   break;\n               case 'loading':\n                   statusMessage.className += ' bg-blue-100 text-blue-800 border border-blue-200';\n                   break;\n           }\n           \n           statusMessage.textContent = message;\n       }\n   </script>\n</body>\n</html>"},"type":"n8n-nodes-base.html","typeVersion":1.2,"position":[160,260],"id":"3b18dee8-76e2-4f19-88ba-918247294299","name":"HTML1"},{"parameters":{"respondWith":"text","responseBody":"={{ $json.html }}","options":{}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.3,"position":[380,260],"id":"f094c44c-5eb8-4372-9b02-6c6c9b254b00","name":"Respond to Webhook1"},{"parameters":{"httpMethod":"POST","path":"7bcfb3a8-c514-42bd-9f80-cb1ede1a3d64","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2,"position":[-60,460],"id":"9c7c069a-0bfb-408f-9817-fa9545520534","name":"Webhook2","webhookId":"7bcfb3a8-c514-42bd-9f80-cb1ede1a3d64"},{"parameters":{"path":"c35cc5ef-5a69-4c44-a0b4-4c19473a5c73","responseMode":"responseNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2,"position":[-60,260],"id":"ec9cb7df-aa5f-4625-ad01-91c95f7da356","name":"Webhook3","webhookId":"c35cc5ef-5a69-4c44-a0b4-4c19473a5c73"},{"parameters":{"operation":"binaryToPropery","binaryPropertyName":"file","options":{}},"type":"n8n-nodes-base.extractFromFile","typeVersion":1,"position":[160,460],"id":"041c6e63-09e0-4451-90df-a37e93074dcf","name":"Extract from File1"},{"parameters":{"operation":"toBinary","sourceProperty":"data","options":{}},"type":"n8n-nodes-base.convertToFile","typeVersion":1.1,"position":[380,460],"id":"7ccd585a-8009-4462-8183-254a4138991f","name":"Convert to File1"},{"parameters":{"jsCode":"// Código para converter XML para PDF preservando todas as tags\nconst items = $input.all();\nconst outputItems = [];\n\n// Função para criar PDF preservando estrutura XML completa\nfunction createPdfWithXmlStructure(xmlContent) {\n  try {\n    // Função para formatar XML mantendo todas as tags visíveis\n    const formatXmlForPdf = (xmlString) => {\n      // Limpar apenas espaços desnecessários, mantendo toda estrutura\n      let formatted = xmlString\n        .replace(/>\\s+</g, '>\\n<') // Quebra linha entre tags\n        .replace(/^\\s+|\\s+$/gm, '') // Remove espaços das bordas\n        .split('\\n')\n        .map((line, index) => {\n          // Calcular indentação baseada no nível de aninhamento\n          const openTags = (line.match(/</g) || []).length;\n          const closeTags = (line.match(/\\//g) || []).length;\n          const depth = Math.max(0, (line.match(/<(?!\\/)/g) || []).length - closeTags);\n          const indent = '  '.repeat(depth);\n          \n          return line.trim() ? `${String(index + 1).padStart(4, ' ')}: ${indent}${line.trim()}` : '';\n        })\n        .filter(line => line.trim())\n        .join('\\n');\n      \n      return formatted;\n    };\n    \n    const formattedXml = formatXmlForPdf(xmlContent);\n    const pdfBuffer = generatePdfWithXmlContent(formattedXml, xmlContent);\n    \n    return pdfBuffer;\n    \n  } catch (error) {\n    throw new Error(`Erro ao processar XML: ${error.message}`);\n  }\n}\n\n// Gerar PDF com conteúdo XML estruturado\nfunction generatePdfWithXmlContent(formattedText, originalXml) {\n  const lines = formattedText.split('\\n');\n  const maxLinesPerPage = 45; // Menos linhas para dar espaço ao cabeçalho\n  const pages = [];\n  \n  // Dividir em páginas\n  for (let i = 0; i < lines.length; i += maxLinesPerPage) {\n    pages.push(lines.slice(i, i + maxLinesPerPage));\n  }\n  \n  let pdfObjects = [];\n  let objectId = 1;\n  \n  // Objeto 1: Catálogo\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Catalog /Pages 2 0 R >>`\n  });\n  \n  // Objeto 2: Páginas pai\n  const pageRefs = pages.map((_, index) => `${3 + index * 2} 0 R`).join(' ');\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Pages /Kids [${pageRefs}] /Count ${pages.length} >>`\n  });\n  \n  // Criar páginas com conteúdo XML\n  pages.forEach((pageLines, pageIndex) => {\n    const pageId = objectId++;\n    const contentId = objectId++;\n    \n    // Objeto da página\n    pdfObjects.push({\n      id: pageId,\n      content: `<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents ${contentId} 0 R /Resources << /Font << /F1 << /Type /Font /Subtype /Type1 /BaseFont /Courier >> /F2 << /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >> >> >> >>`\n    });\n    \n    // Preparar conteúdo da página com cabeçalho\n    let streamContent = 'BT\\n';\n    \n    // Cabeçalho da página\n    streamContent += '/F2 12 Tf 50 750 Td\\n';\n    streamContent += `(Estrutura XML - Página ${pageIndex + 1} de ${pages.length}) Tj\\n`;\n    streamContent += '0 -20 Td\\n';\n    streamContent += '/F1 8 Tf\\n';\n    streamContent += `(Preservando todas as tags XML para indexação RAG) Tj\\n`;\n    streamContent += '0 -15 Td\\n';\n    streamContent += '(____________________________________________________________) Tj\\n';\n    streamContent += '0 -20 Td\\n';\n    \n    // Conteúdo XML\n    streamContent += '/F1 9 Tf\\n';\n    streamContent += '10 TL\\n'; // Line leading\n    \n    pageLines.forEach(line => {\n      // Escapar caracteres especiais do PDF\n      const escapedLine = line\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\(/g, '\\\\(')\n        .replace(/\\)/g, '\\\\)')\n        .replace(/\\r/g, '')\n        .substring(0, 85); // Limitar tamanho da linha\n      \n      streamContent += `(${escapedLine}) Tj T*\\n`;\n    });\n    \n    streamContent += 'ET';\n    \n    // Objeto de conteúdo\n    pdfObjects.push({\n      id: contentId,\n      content: `<< /Length ${streamContent.length} >>\\nstream\\n${streamContent}\\nendstream`\n    });\n  });\n  \n  // Montar PDF final\n  let pdf = '%PDF-1.4\\n';\n  let xrefTable = [];\n  \n  // Adicionar objetos\n  pdfObjects.forEach(obj => {\n    xrefTable.push(pdf.length);\n    pdf += `${obj.id} 0 obj\\n${obj.content}\\nendobj\\n`;\n  });\n  \n  // Tabela xref\n  const xrefPos = pdf.length;\n  pdf += 'xref\\n';\n  pdf += `0 ${pdfObjects.length + 1}\\n`;\n  pdf += '0000000000 65535 f \\n';\n  \n  xrefTable.forEach(pos => {\n    pdf += pos.toString().padStart(10, '0') + ' 00000 n \\n';\n  });\n  \n  // Trailer\n  pdf += 'trailer\\n';\n  pdf += `<< /Size ${pdfObjects.length + 1} /Root 1 0 R >>\\n`;\n  pdf += 'startxref\\n';\n  pdf += xrefPos + '\\n';\n  pdf += '%%EOF\\n';\n  \n  return Buffer.from(pdf, 'utf8');\n}\n\n// Processar todos os items\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  try {\n    // Extrair conteúdo XML\n    let xmlContent = '';\n    \n    if (item.json && item.json.data) {\n      xmlContent = item.json.data;\n    } else if (item.binary && item.binary.data && item.binary.data.data) {\n      xmlContent = Buffer.from(item.binary.data.data, 'base64').toString('utf8');\n    }\n    \n    if (!xmlContent || xmlContent.trim() === '') {\n      throw new Error('Conteúdo XML não encontrado ou vazio');\n    }\n    \n    console.log(`Processando XML com ${xmlContent.length} caracteres`);\n    \n    // Converter para PDF preservando estrutura\n    const pdfBuffer = createPdfWithXmlStructure(xmlContent);\n    \n    // Preparar dados para RAG (manter XML original + PDF)\n    const outputItem = {\n      json: {\n        // Dados para o RAG\n        originalXml: xmlContent, // XML original completo para indexação\n        fileName: `xml_structured_${Date.now()}.pdf`,\n        mimeType: 'application/pdf',\n        fileSize: pdfBuffer.length,\n        xmlSize: xmlContent.length,\n        processingDate: new Date().toISOString(),\n        tags: extractXmlTags(xmlContent), // Extrair tags para facilitar busca\n        success: true\n      },\n      binary: {\n        data: {\n          data: pdfBuffer.toString('base64'),\n          mimeType: 'application/pdf',\n          fileName: `xml_structured_${Date.now()}.pdf`,\n          fileExtension: 'pdf'\n        }\n      }\n    };\n    \n    outputItems.push(outputItem);\n    \n  } catch (error) {\n    console.error(`Erro no item ${i}:`, error);\n    \n    outputItems.push({\n      json: {\n        error: error.message,\n        itemIndex: i,\n        success: false,\n        processingDate: new Date().toISOString()\n      }\n    });\n  }\n}\n\n// Função auxiliar para extrair tags XML para indexação\nfunction extractXmlTags(xmlContent) {\n  try {\n    const tagMatches = xmlContent.match(/<[^>]+>/g) || [];\n    const uniqueTags = [...new Set(tagMatches.map(tag => {\n      return tag.replace(/[<>\\/]/g, '').split(' ')[0];\n    }))];\n    return uniqueTags.filter(tag => tag.length > 0);\n  } catch (error) {\n    return [];\n  }\n}\n\nreturn outputItems;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[620,460],"id":"48a13360-d1a8-4b69-af00-21aa9da21241","name":"Code2"},{"parameters":{"content":"# ENVIANDO DOCUMETOS VIA INTERFACE","height":700,"width":1540,"color":2},"type":"n8n-nodes-base.stickyNote","position":[-140,120],"typeVersion":1,"id":"55435b03-c096-4625-b442-3a8987ea1ced","name":"Sticky Note1"},{"parameters":{"options":{"dimensions":1024}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[860,660],"id":"146efd06-7872-4c1b-8c8c-497c88200300","name":"Embeddings OpenAI2","credentials":{"openAiApi":{"id":"bEHAhmQV1LUjIUXy","name":"OpenAi account"}}},{"parameters":{"dataType":"binary","options":{}},"type":"@n8n/n8n-nodes-langchain.documentDefaultDataLoader","typeVersion":1.1,"position":[1020,660],"id":"8ccfcff3-1b8f-4b99-9ef4-3813e78571b8","name":"Default Data Loader2"},{"parameters":{"options":{"systemMessage":"VOCÊ É UM ESPECIALISTA EM CONSULTA DE MARCAS DO INPI\n\n=== INSTRUÇÕES PRINCIPAIS ===\n\nSua função é consultar a base de dados vetorizada das revistas do INPI para verificar disponibilidade de marcas e localizar processos específicos.\n\n=== ESTRATÉGIA DE BUSCA ===\n\nPARA NÚMEROS DE PROCESSO:\n1. SEMPRE faça múltiplas tentativas de busca:\n   - Busque o número EXATO como digitado pelo usuário\n   - Busque apenas os dígitos (sem pontos, barras, espaços)\n   - Busque com formatação padrão INPI (ex: 908423284 E também 90.842.3284)\n   - Use threshold MUITO BAIXO (0.1-0.3) para números de processo\n\n2. Busque em TODOS os campos disponíveis:\n   - Campo \"content\" \n   - Campo \"metadata\"\n   - Qualquer campo que contenha informações do processo\n\nPARA NOMES DE MARCAS:\n1. Realize estas buscas sequenciais:\n   - Busca exata pelo nome digitado\n   - Busca sem acentos e caracteres especiais\n   - Busca em maiúsculas E minúsculas\n   - Busca por palavras individuais da marca\n   - Busca fonética (sons similares)\n\n2. Configure thresholds progressivos:\n   - Primeira busca: threshold 0.9 (muito similar)\n   - Segunda busca: threshold 0.7 (moderadamente similar)\n   - Terceira busca: threshold 0.5 (levemente similar)\n\n=== FORMATO DE RESPOSTA ===\n\nPARA PROCESSOS ENCONTRADOS:\n- Número do processo\n- Nome da marca\n- Classe Nice\n- Status atual (deferido/indeferido/em análise)\n- Data de depósito/registro\n- Titular\n\nPARA CONSULTA DE DISPONIBILIDADE:\n- Status: DISPONÍVEL / INDISPONÍVEL / RISCO\n- Marcas conflitantes encontradas\n- Nível de risco: BAIXO/MÉDIO/ALTO\n- Recomendação legal específica\n\n=== IMPORTANTE ===\n- NUNCA responda \"não encontrado\" sem fazer pelo menos 3 tentativas de busca diferentes\n- SEMPRE explique quantas buscas você fez e com quais termos\n- Se realmente não encontrar, peça ao usuário para verificar se o número/nome está correto\n- Para números de processo, eles SEMPRE devem existir se foram fornecidos corretamente\n\nEXECUTE SEMPRE MÚLTIPLAS BUSCAS ANTES DE CONCLUIR QUE ALGO NÃO EXISTE!"}},"type":"@n8n/n8n-nodes-langchain.agent","typeVersion":2,"position":[2080,260],"id":"d2e2667a-46b8-4301-91d2-6efb7f9ae34b","name":"AI Agent"},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.chatTrigger","typeVersion":1.1,"position":[1820,260],"id":"2487ab5f-88a4-458c-835b-7c604ebde482","name":"When chat message received","webhookId":"ad66486c-fc7d-4c00-be68-f70914fd7043"},{"parameters":{"model":{"__rl":true,"value":"gpt-4o","mode":"list","cachedResultName":"gpt-4o"},"options":{}},"type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","typeVersion":1.2,"position":[2040,480],"id":"0d9900d2-8bae-42b6-a202-bc5bf530a6e6","name":"OpenAI Chat Model","credentials":{"openAiApi":{"id":"bEHAhmQV1LUjIUXy","name":"OpenAi account"}}},{"parameters":{"contextWindowLength":10},"type":"@n8n/n8n-nodes-langchain.memoryBufferWindow","typeVersion":1.3,"position":[2180,480],"id":"458dea22-ad5e-437b-8e3a-03b3c034d776","name":"Simple Memory"},{"parameters":{"mode":"retrieve-as-tool","toolDescription":"BUSQUE ESSA BASE DE DADOS PARA PROCESSAR AS PERGUNTAS DO USUARIO","pineconeIndex":{"__rl":true,"value":"inpi","mode":"list","cachedResultName":"inpi"},"options":{}},"type":"@n8n/n8n-nodes-langchain.vectorStorePinecone","typeVersion":1.3,"position":[2360,460],"id":"cd9fb290-6d90-4a26-aa2e-dd456ae2eef3","name":"Pinecone Vector Store1","credentials":{"pineconeApi":{"id":"tZGLab4uo4TJ4k4Y","name":"PineconeApi account"}}},{"parameters":{"options":{"dimensions":1024}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[2440,600],"id":"40b53329-c075-4027-81a6-455fcb442af4","name":"Embeddings OpenAI","credentials":{"openAiApi":{"id":"bEHAhmQV1LUjIUXy","name":"OpenAi account"}}},{"parameters":{"jsCode":"// Código para converter XML para PDF preservando todas as tags\nconst items = $input.all();\nconst outputItems = [];\n\n// Função para criar PDF preservando estrutura XML completa\nfunction createPdfWithXmlStructure(xmlContent) {\n  try {\n    // Função para formatar XML mantendo todas as tags visíveis\n    const formatXmlForPdf = (xmlString) => {\n      // Limpar apenas espaços desnecessários, mantendo toda estrutura\n      let formatted = xmlString\n        .replace(/>\\s+</g, '>\\n<') // Quebra linha entre tags\n        .replace(/^\\s+|\\s+$/gm, '') // Remove espaços das bordas\n        .split('\\n')\n        .map((line, index) => {\n          // Calcular indentação baseada no nível de aninhamento\n          const openTags = (line.match(/</g) || []).length;\n          const closeTags = (line.match(/\\//g) || []).length;\n          const depth = Math.max(0, (line.match(/<(?!\\/)/g) || []).length - closeTags);\n          const indent = '  '.repeat(depth);\n          \n          return line.trim() ? `${String(index + 1).padStart(4, ' ')}: ${indent}${line.trim()}` : '';\n        })\n        .filter(line => line.trim())\n        .join('\\n');\n      \n      return formatted;\n    };\n    \n    const formattedXml = formatXmlForPdf(xmlContent);\n    const pdfBuffer = generatePdfWithXmlContent(formattedXml, xmlContent);\n    \n    return pdfBuffer;\n    \n  } catch (error) {\n    throw new Error(`Erro ao processar XML: ${error.message}`);\n  }\n}\n\n// Gerar PDF com conteúdo XML estruturado\nfunction generatePdfWithXmlContent(formattedText, originalXml) {\n  const lines = formattedText.split('\\n');\n  const maxLinesPerPage = 45; // Menos linhas para dar espaço ao cabeçalho\n  const pages = [];\n  \n  // Dividir em páginas\n  for (let i = 0; i < lines.length; i += maxLinesPerPage) {\n    pages.push(lines.slice(i, i + maxLinesPerPage));\n  }\n  \n  let pdfObjects = [];\n  let objectId = 1;\n  \n  // Objeto 1: Catálogo\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Catalog /Pages 2 0 R >>`\n  });\n  \n  // Objeto 2: Páginas pai\n  const pageRefs = pages.map((_, index) => `${3 + index * 2} 0 R`).join(' ');\n  pdfObjects.push({\n    id: objectId++,\n    content: `<< /Type /Pages /Kids [${pageRefs}] /Count ${pages.length} >>`\n  });\n  \n  // Criar páginas com conteúdo XML\n  pages.forEach((pageLines, pageIndex) => {\n    const pageId = objectId++;\n    const contentId = objectId++;\n    \n    // Objeto da página\n    pdfObjects.push({\n      id: pageId,\n      content: `<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents ${contentId} 0 R /Resources << /Font << /F1 << /Type /Font /Subtype /Type1 /BaseFont /Courier >> /F2 << /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >> >> >> >>`\n    });\n    \n    // Preparar conteúdo da página com cabeçalho\n    let streamContent = 'BT\\n';\n    \n    // Cabeçalho da página\n    streamContent += '/F2 12 Tf 50 750 Td\\n';\n    streamContent += `(Estrutura XML - Página ${pageIndex + 1} de ${pages.length}) Tj\\n`;\n    streamContent += '0 -20 Td\\n';\n    streamContent += '/F1 8 Tf\\n';\n    streamContent += `(Preservando todas as tags XML para indexação RAG) Tj\\n`;\n    streamContent += '0 -15 Td\\n';\n    streamContent += '(____________________________________________________________) Tj\\n';\n    streamContent += '0 -20 Td\\n';\n    \n    // Conteúdo XML\n    streamContent += '/F1 9 Tf\\n';\n    streamContent += '10 TL\\n'; // Line leading\n    \n    pageLines.forEach(line => {\n      // Escapar caracteres especiais do PDF\n      const escapedLine = line\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\(/g, '\\\\(')\n        .replace(/\\)/g, '\\\\)')\n        .replace(/\\r/g, '')\n        .substring(0, 85); // Limitar tamanho da linha\n      \n      streamContent += `(${escapedLine}) Tj T*\\n`;\n    });\n    \n    streamContent += 'ET';\n    \n    // Objeto de conteúdo\n    pdfObjects.push({\n      id: contentId,\n      content: `<< /Length ${streamContent.length} >>\\nstream\\n${streamContent}\\nendstream`\n    });\n  });\n  \n  // Montar PDF final\n  let pdf = '%PDF-1.4\\n';\n  let xrefTable = [];\n  \n  // Adicionar objetos\n  pdfObjects.forEach(obj => {\n    xrefTable.push(pdf.length);\n    pdf += `${obj.id} 0 obj\\n${obj.content}\\nendobj\\n`;\n  });\n  \n  // Tabela xref\n  const xrefPos = pdf.length;\n  pdf += 'xref\\n';\n  pdf += `0 ${pdfObjects.length + 1}\\n`;\n  pdf += '0000000000 65535 f \\n';\n  \n  xrefTable.forEach(pos => {\n    pdf += pos.toString().padStart(10, '0') + ' 00000 n \\n';\n  });\n  \n  // Trailer\n  pdf += 'trailer\\n';\n  pdf += `<< /Size ${pdfObjects.length + 1} /Root 1 0 R >>\\n`;\n  pdf += 'startxref\\n';\n  pdf += xrefPos + '\\n';\n  pdf += '%%EOF\\n';\n  \n  return Buffer.from(pdf, 'utf8');\n}\n\n// Processar todos os items\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  try {\n    // Extrair conteúdo XML\n    let xmlContent = '';\n    \n    if (item.json && item.json.data) {\n      xmlContent = item.json.data;\n    } else if (item.binary && item.binary.data && item.binary.data.data) {\n      xmlContent = Buffer.from(item.binary.data.data, 'base64').toString('utf8');\n    }\n    \n    if (!xmlContent || xmlContent.trim() === '') {\n      throw new Error('Conteúdo XML não encontrado ou vazio');\n    }\n    \n    console.log(`Processando XML com ${xmlContent.length} caracteres`);\n    \n    // Converter para PDF preservando estrutura\n    const pdfBuffer = createPdfWithXmlStructure(xmlContent);\n    \n    // Preparar dados para RAG (manter XML original + PDF)\n    const outputItem = {\n      json: {\n        // Dados para o RAG\n        originalXml: xmlContent, // XML original completo para indexação\n        fileName: `xml_structured_${Date.now()}.pdf`,\n        mimeType: 'application/pdf',\n        fileSize: pdfBuffer.length,\n        xmlSize: xmlContent.length,\n        processingDate: new Date().toISOString(),\n        tags: extractXmlTags(xmlContent), // Extrair tags para facilitar busca\n        success: true\n      },\n      binary: {\n        data: {\n          data: pdfBuffer.toString('base64'),\n          mimeType: 'application/pdf',\n          fileName: `xml_structured_${Date.now()}.pdf`,\n          fileExtension: 'pdf'\n        }\n      }\n    };\n    \n    outputItems.push(outputItem);\n    \n  } catch (error) {\n    console.error(`Erro no item ${i}:`, error);\n    \n    outputItems.push({\n      json: {\n        error: error.message,\n        itemIndex: i,\n        success: false,\n        processingDate: new Date().toISOString()\n      }\n    });\n  }\n}\n\n// Função auxiliar para extrair tags XML para indexação\nfunction extractXmlTags(xmlContent) {\n  try {\n    const tagMatches = xmlContent.match(/<[^>]+>/g) || [];\n    const uniqueTags = [...new Set(tagMatches.map(tag => {\n      return tag.replace(/[<>\\/]/g, '').split(' ')[0];\n    }))];\n    return uniqueTags.filter(tag => tag.length > 0);\n  } catch (error) {\n    return [];\n  }\n}\n\nreturn outputItems;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1380,980],"id":"db988983-51a6-41d3-9374-4774012ff024","name":"Code1"},{"parameters":{"resource":"fileFolder","limit":1,"filter":{"folderId":{"__rl":true,"value":"1os3vZhfnEsUfMYFDchwNcw51NzGTtE-I","mode":"list","cachedResultName":"REVISTAS_INPI","cachedResultUrl":"https://drive.google.com/drive/folders/1os3vZhfnEsUfMYFDchwNcw51NzGTtE-I"}},"options":{"fields":["id"]}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[500,1000],"id":"c41c0a84-2203-41ce-97e4-2b622e7390d1","name":"Google Drive","credentials":{"googleDriveOAuth2Api":{"id":"UMUzXd6peuAPf6IA","name":"Google Drive account"}}},{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[260,1000],"id":"3f014e6d-1bc6-4237-9e5b-8944efa186d6","name":"When clicking ‘Execute workflow’"},{"parameters":{"options":{}},"type":"n8n-nodes-base.splitInBatches","typeVersion":3,"position":[760,1020],"id":"3f6f7d37-de93-4a5f-985b-0254765c6f3c","name":"Loop Over Items"},{"parameters":{"operation":"download","fileId":{"__rl":true,"value":"={{ $json.id }}","mode":"id"},"options":{}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[1120,980],"id":"833904f7-5f05-4fe6-8f66-ac4ee08b6b1c","name":"Google Drive1","credentials":{"googleDriveOAuth2Api":{"id":"UMUzXd6peuAPf6IA","name":"Google Drive account"}}},{"parameters":{"operation":"move","fileId":{"__rl":true,"value":"={{ $('Google Drive1').item.json.id }}","mode":"id"},"driveId":{"__rl":true,"mode":"list","value":"My Drive"},"folderId":{"__rl":true,"value":"1L5LA8fk_-7Epcf5B70GSzWq6eHWv6I_p","mode":"list","cachedResultName":"PROCESSADOS","cachedResultUrl":"https://drive.google.com/drive/folders/1L5LA8fk_-7Epcf5B70GSzWq6eHWv6I_p"}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[2380,1040],"id":"24bf6d3e-d27b-4be0-a53a-be4374165c8f","name":"Google Drive2","credentials":{"googleDriveOAuth2Api":{"id":"UMUzXd6peuAPf6IA","name":"Google Drive account"}}},{"parameters":{"content":"# ENVIANDO DOCUMENTOS VIA GOOGLE DRIVE","height":420,"width":3120,"color":4},"type":"n8n-nodes-base.stickyNote","position":[-140,860],"typeVersion":1,"id":"0e17416b-ecb6-46d3-b3b5-e3fd67b15721","name":"Sticky Note"},{"parameters":{"content":"# CHAT AGENT","height":700,"width":1540,"color":6},"type":"n8n-nodes-base.stickyNote","position":[1440,120],"typeVersion":1,"id":"a932a888-82c5-4599-b441-e9bfc434fefd","name":"Sticky Note2"},{"parameters":{"mode":"insert","pineconeIndex":{"__rl":true,"value":"inpi","mode":"list","cachedResultName":"inpi"},"options":{}},"type":"@n8n/n8n-nodes-langchain.vectorStorePinecone","typeVersion":1.3,"position":[1820,900],"id":"99f50b52-c3a0-44f6-ac4b-e7935a8b6042","name":"Pinecone Vector Store2","credentials":{"pineconeApi":{"id":"tZGLab4uo4TJ4k4Y","name":"PineconeApi account"}}},{"parameters":{"options":{"dimensions":1024}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[1820,1080],"id":"268b2bd9-320e-4408-a752-61b0d58fe39d","name":"Embeddings OpenAI3","credentials":{"openAiApi":{"id":"bEHAhmQV1LUjIUXy","name":"OpenAi account"}}},{"parameters":{"dataType":"binary","options":{}},"type":"@n8n/n8n-nodes-langchain.documentDefaultDataLoader","typeVersion":1.1,"position":[1980,1080],"id":"2ce45d30-a995-4cdc-a701-e2f62656d342","name":"Default Data Loader"}],"connections":{"HTML1":{"main":[[{"node":"Respond to Webhook1","type":"main","index":0}]]},"Webhook2":{"main":[[{"node":"Extract from File1","type":"main","index":0}]]},"Webhook3":{"main":[[{"node":"HTML1","type":"main","index":0}]]},"Extract from File1":{"main":[[{"node":"Convert to File1","type":"main","index":0}]]},"Convert to File1":{"main":[[{"node":"Code2","type":"main","index":0}]]},"Code2":{"main":[[{"node":"Pinecone Vector Store","type":"main","index":0}]]},"Embeddings OpenAI2":{"ai_embedding":[[{"node":"Pinecone Vector Store","type":"ai_embedding","index":0}]]},"Default Data Loader2":{"ai_document":[[{"node":"Pinecone Vector Store","type":"ai_document","index":0}]]},"When chat message received":{"main":[[{"node":"AI Agent","type":"main","index":0}]]},"OpenAI Chat Model":{"ai_languageModel":[[{"node":"AI Agent","type":"ai_languageModel","index":0}]]},"Simple Memory":{"ai_memory":[[{"node":"AI Agent","type":"ai_memory","index":0}]]},"Pinecone Vector Store1":{"ai_tool":[[{"node":"AI Agent","type":"ai_tool","index":0}]]},"Embeddings OpenAI":{"ai_embedding":[[{"node":"Pinecone Vector Store1","type":"ai_embedding","index":0}]]},"Code1":{"main":[[{"node":"Pinecone Vector Store2","type":"main","index":0}]]},"Google Drive":{"main":[[{"node":"Loop Over Items","type":"main","index":0}]]},"When clicking ‘Execute workflow’":{"main":[[{"node":"Google Drive","type":"main","index":0}]]},"Loop Over Items":{"main":[[],[{"node":"Google Drive1","type":"main","index":0}]]},"Google Drive1":{"main":[[{"node":"Code1","type":"main","index":0}]]},"Google Drive2":{"main":[[{"node":"Loop Over Items","type":"main","index":0}]]},"Embeddings OpenAI3":{"ai_embedding":[[{"node":"Pinecone Vector Store2","type":"ai_embedding","index":0}]]},"Default Data Loader":{"ai_document":[[{"node":"Pinecone Vector Store2","type":"ai_document","index":0}]]},"Pinecone Vector Store2":{"main":[[{"node":"Google Drive2","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"effd502e-8e12-4b72-a926-9db610030e2d","triggerCount":0,"shared":[{"updatedAt":"2025-06-24T15:04:40.879Z","createdAt":"2025-06-24T15:04:40.879Z","role":"workflow:owner","workflowId":"n3fSkJxb01QMoxuO","projectId":"BlSED80HESP48veq"}],"tags":[]}